# python-attribute-access-modifiers

Tired of typing `@property` just to make a read-only instance variable? Find yourself wishing for C#'s `{get; set;}` syntax? Look no further than PAAM, which auto-generates property getters, setter, and deleters for you!

## Quickstart

Once installed, just use the overloaded `|` operator between an instance variable and one of the predefined constants `GET`, `SET`, or `DEL` **in the `__init__` method**. Make sure to decorate the enclosing class with `property_access_mod_class`.

```python
from getset import SET, property_access_mod_class

@property_access_mod_class
class Test:
    def __init__(self, a: int):
        self.a = a | GET

>>> obj = Test(15)
>>> obj.a
>>> 15
>>> obj.a = 5 # raises AttributeError: can't set attribute
```

Property access modifiers can also be chained (order doesn't matter):

```python
from getset import SET, GET, DEL, property_access_mod_class

@property_access_mod_class
class Test:
    def __init__(self, a: int):
        self.a = a | GET | SET

>>> obj = Test(15)
>>> obj.a
>>> 15
>>> obj.a = 5
>>> obj.a
>>> 5
>>> del obj.a # raises AttributeError: can't delete attribute
```

## Caveats (all planned to be fixed in future release)
* `GET`, `SET`, `DEL` have no effect outside constructor method
* Since decorator is called relatively late, `NameError` is raised if a custom property method is created alongisde an autogenerated one:
    ```python
    from getset import GET, property_access_mod_class

    @property_access_mod_class
    class Test:
        def __init__(self, a: int):
            self.a = a | GET
        
        @a.setter # throws NameError: name 'a' is not defined
        def set_a(self, other):
            print('custom setter called')
            self._a = a
    ```
    Custom methods can still be created, just not property decorators.
    ```python
    @property_access_mod_class
    class Test:
        def __init__(self, a: int):
            self.a = a | GET
        
        def set_a(self, other): # this works
            print('custom setter called')
            self._a = a
    ```
* The type of any variable "annotated" with `GET`, `SET`, or `DEL` is `_PropertyAccessModifierBase`. This means `mypy` support and IDE type hinting are most likely broken.
* No tests